<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureTransfer - Truy·ªÅn File An To√†n</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .file-input-area {
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .file-input-area:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-input-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .upload-icon {
            font-size: 3rem;
            color: #a0aec0;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-danger {
            background: linear-gradient(45deg, #f56565, #e53e3e);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            margin: 5px 2px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .file-info {
            background: #f7fafc;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .signature-display {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            word-break: break-all;
            max-height: 150px;
            overflow-y: auto;
        }

        .signature-file-input {
            border: 2px dashed #cbd5e0;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .signature-file-input:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .status {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status.success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }

        .status.info {
            background: #bee3f8;
            color: #2a4365;
            border: 1px solid #90cdf4;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .transfer-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .transfer-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .qr-code {
            width: 200px;
            height: 200px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            color: #718096;
        }

        .key-fingerprint {
            background: #2d3748;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            margin: 10px 0;
            word-break: break-all;
        }

        .key-info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .key-info-item {
            background: #f7fafc;
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .key-info-item strong {
            color: #4a5568;
        }

        .verification-section {
            background: #f7fafc;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border: 2px solid #e2e8f0;
        }

        .verification-section h4 {
            color: #4a5568;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .transfer-options {
                grid-template-columns: 1fr;
            }

            .key-info-grid {
                grid-template-columns: 1fr;
            }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .5;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê SecureTransfer</h1>
            <p>Truy·ªÅn file an to√†n v·ªõi ch·ªØ k√Ω s·ªë v√† m√£ h√≥a</p>
        </div>

        <div class="main-content">
            <!-- Key Management Section -->
            <div class="card">
                <h2>
                    <span class="icon">üîë</span>
                    Qu·∫£n L√Ω Kh√≥a
                </h2>
                
                <div id="keyInfo">
                    <p class="status info">Ch∆∞a c√≥ c·∫∑p kh√≥a n√†o ƒë∆∞·ª£c t·∫°o</p>
                </div>
                
                <button class="btn" id="generateKeysBtn">
                    üîë T·∫°o C·∫∑p Kh√≥a
                </button>
                
                <button class="btn btn-secondary" id="importPublicKeyBtn">
                    üì• Nh·∫≠p Public Key
                </button>
                
                <button class="btn btn-secondary" id="exportPublicKeyBtn" disabled>
                    üì§ Xu·∫•t Public Key
                </button>
                
                <button class="btn btn-secondary" id="downloadPublicKeyBtn" disabled>
                    üíæ T·∫£i Public Key
                </button>
                
                <input type="file" class="file-input" id="publicKeyInput" accept=".pem,.pub,.key">
                
                <div id="publicKeyDisplay" style="display: none;">
                    <h4>üîê Public Key:</h4>
                    <div class="signature-display" id="publicKeyContent"></div>
                    <button class="btn btn-small" id="copyPublicKeyBtn">
                        üìã Copy Public Key
                    </button>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="card">
                <h2>
                    <span class="icon">üì§</span>
                    T·∫£i l√™n File
                </h2>
                
                <div class="file-input-area" id="fileInputArea">
                    <div class="upload-icon">üìÅ</div>
                    <p>K√©o th·∫£ file v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</p>
                    <input type="file" class="file-input" id="fileInput" multiple>
                </div>

                <div id="fileList"></div>
                
                <button class="btn" id="generateSignatureBtn" disabled>
                    üîè T·∫°o Ch·ªØ K√Ω S·ªë
                </button>
                
                <button class="btn btn-secondary" id="encryptBtn" disabled>
                    üîí M√£ H√≥a File
                </button>
            </div>

            <!-- Signature Section -->
            <div class="card">
                <h2>
                    <span class="icon">üîê</span>
                    Ch·ªØ K√Ω S·ªë
                </h2>
                
                <div id="signatureInfo">
                    <p class="status info">Ch∆∞a c√≥ ch·ªØ k√Ω s·ªë n√†o ƒë∆∞·ª£c t·∫°o</p>
                </div>
                
                <button class="btn" id="verifySignatureBtn" disabled>
                    ‚úÖ X√°c Th·ª±c Ch·ªØ K√Ω
                </button>
                
                <button class="btn btn-secondary" id="downloadSignatureBtn" disabled>
                    üíæ T·∫£i Ch·ªØ K√Ω
                </button>
            </div>

            <!-- Recipient Section -->
            <div class="card">
                <h2>
                    <span class="icon">üë•</span>
                    Ng∆∞·ªùi Nh·∫≠n
                </h2>
                
                <div class="file-input-area" id="recipientKeyArea">
                    <div class="upload-icon">üîë</div>
                    <p>K√©o th·∫£ Public Key c·ªßa ng∆∞·ªùi nh·∫≠n</p>
                    <input type="file" class="file-input" id="recipientKeyInput" accept=".pem,.pub,.key">
                </div>
                
                <div id="recipientKeyInfo"></div>
                
                <button class="btn" id="encryptForRecipientBtn" disabled>
                    üîí M√£ H√≥a Cho Ng∆∞·ªùi Nh·∫≠n
                </button>
                
                <!-- Enhanced Verification Section -->
                <div class="verification-section">
                    <h4>üîç X√°c Th·ª±c Ch·ªØ K√Ω T·ª´ Ng∆∞·ªùi G·ª≠i</h4>
                    
                    <div class="signature-file-input" id="signatureFileArea">
                        <div style="font-size: 2rem; color: #a0aec0; margin-bottom: 10px;">üìù</div>
                        <p>K√©o th·∫£ file ch·ªØ k√Ω (.json) v√†o ƒë√¢y</p>
                        <input type="file" class="file-input" id="signatureFileInput" accept=".json">
                    </div>
                    
                    <div id="signatureFileInfo"></div>
                    
                    <button class="btn btn-secondary" id="verifyRecipientSignatureBtn" disabled>
                        ‚úÖ X√°c Th·ª±c Ch·ªØ K√Ω
                    </button>
                    
                    <div id="verificationResult"></div>
                </div>
            </div>
        </div>

        <!-- Transfer Section -->
        <div class="transfer-section full-width">
            <h2>
                <span class="icon">üåê</span>
                Chia S·∫ª File
            </h2>
            
            <div class="transfer-options">
                <div>
                    <h3>üì± M√£ QR</h3>
                    <div class="qr-code" id="qrCode">
                        M√£ QR s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y
                    </div>
                    <button class="btn" id="generateQRBtn" disabled>
                        T·∫°o M√£ QR
                    </button>
                </div>
                
                <div>
                    <h3>üîó Li√™n K·∫øt Chia S·∫ª</h3>
                    <div class="file-info">
                        <p><strong>Tr·∫°ng th√°i:</strong> <span id="shareStatus">Ch∆∞a s·∫µn s√†ng</span></p>
                        <p><strong>H·∫øt h·∫°n:</strong> <span id="expireTime">-</span></p>
                    </div>
                    <button class="btn" id="generateLinkBtn" disabled>
                        üîó T·∫°o Li√™n K·∫øt
                    </button>
                    <button class="btn btn-danger" id="revokeLinkBtn" disabled>
                        üö´ Thu H·ªìi Li√™n K·∫øt
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SecureFileTransfer {
            constructor() {
                this.files = [];
                this.signatures = {};
                this.encryptedFiles = {};
                this.shareLinks = {};
                this.keyPair = null;
                this.publicKey = null;
                this.privateKey = null;
                this.recipientPublicKey = null;
                this.senderSignature = null;
                this.initEventListeners();
            }

            initEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const fileInputArea = document.getElementById('fileInputArea');
                const publicKeyInput = document.getElementById('publicKeyInput');
                const recipientKeyInput = document.getElementById('recipientKeyInput');
                const recipientKeyArea = document.getElementById('recipientKeyArea');
                const signatureFileInput = document.getElementById('signatureFileInput');
                const signatureFileArea = document.getElementById('signatureFileArea');
                
                // File input events
                fileInputArea.addEventListener('click', () => fileInput.click());
                fileInputArea.addEventListener('dragover', this.handleDragOver.bind(this));
                fileInputArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                fileInputArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Key management events
                document.getElementById('generateKeysBtn').addEventListener('click', this.generateKeyPair.bind(this));
                document.getElementById('importPublicKeyBtn').addEventListener('click', () => publicKeyInput.click());
                document.getElementById('exportPublicKeyBtn').addEventListener('click', this.exportPublicKey.bind(this));
                document.getElementById('downloadPublicKeyBtn').addEventListener('click', this.downloadPublicKey.bind(this));
                document.getElementById('copyPublicKeyBtn').addEventListener('click', this.copyPublicKey.bind(this));
                publicKeyInput.addEventListener('change', this.handlePublicKeyImport.bind(this));

                // Recipient key events
                recipientKeyArea.addEventListener('click', () => recipientKeyInput.click());
                recipientKeyArea.addEventListener('dragover', this.handleDragOver.bind(this));
                recipientKeyArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                recipientKeyArea.addEventListener('drop', this.handleRecipientKeyDrop.bind(this));
                recipientKeyInput.addEventListener('change', this.handleRecipientKeySelect.bind(this));

                // Signature file events
                signatureFileArea.addEventListener('click', () => signatureFileInput.click());
                signatureFileArea.addEventListener('dragover', this.handleSignatureDragOver.bind(this));
                signatureFileArea.addEventListener('dragleave', this.handleSignatureDragLeave.bind(this));
                signatureFileArea.addEventListener('drop', this.handleSignatureFileDrop.bind(this));
                signatureFileInput.addEventListener('change', this.handleSignatureFileSelect.bind(this));

                // Button events
                document.getElementById('generateSignatureBtn').addEventListener('click', this.generateSignature.bind(this));
                document.getElementById('encryptBtn').addEventListener('click', this.encryptFiles.bind(this));
                document.getElementById('verifySignatureBtn').addEventListener('click', this.verifySignature.bind(this));
                document.getElementById('downloadSignatureBtn').addEventListener('click', this.downloadSignature.bind(this));
                document.getElementById('generateQRBtn').addEventListener('click', this.generateQR.bind(this));
                document.getElementById('generateLinkBtn').addEventListener('click', this.generateShareLink.bind(this));
                document.getElementById('revokeLinkBtn').addEventListener('click', this.revokeShareLink.bind(this));
                document.getElementById('encryptForRecipientBtn').addEventListener('click', this.encryptForRecipient.bind(this));
                document.getElementById('verifyRecipientSignatureBtn').addEventListener('click', this.verifyRecipientSignature.bind(this));
            }

            async generateKeyPair() {
                const btn = document.getElementById('generateKeysBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang t·∫°o kh√≥a...';

                try {
                    // Generate RSA key pair for digital signatures and encryption
                    this.keyPair = await crypto.subtle.generateKey(
                        {
                            name: 'RSA-PSS',
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([1, 0, 1]),
                            hash: 'SHA-256'
                        },
                        true,
                        ['sign', 'verify']
                    );

                    this.publicKey = this.keyPair.publicKey;
                    this.privateKey = this.keyPair.privateKey;

                    await this.displayKeyInfo();
                    this.showStatus('C·∫∑p kh√≥a RSA ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!', 'success');
                    
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫°o c·∫∑p kh√≥a: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üîë T·∫°o C·∫∑p Kh√≥a';
                    this.updateButtonStates();
                }
            }

            async displayKeyInfo() {
                if (!this.publicKey) return;

                const publicKeyData = await crypto.subtle.exportKey('spki', this.publicKey);
                const publicKeyPem = this.arrayBufferToPem(publicKeyData, 'PUBLIC KEY');
                const fingerprint = await this.generateKeyFingerprint(this.publicKey);

                const keyInfo = document.getElementById('keyInfo');
                keyInfo.innerHTML = `
                    <div class="status success">
                        ‚úÖ C·∫∑p kh√≥a RSA-2048 ƒë√£ s·∫µn s√†ng
                    </div>
                    <div class="key-info-grid">
                        <div class="key-info-item">
                            <strong>Thu·∫≠t to√°n:</strong> RSA-PSS
                        </div>
                        <div class="key-info-item">
                            <strong>ƒê·ªô d√†i kh√≥a:</strong> 2048 bits
                        </div>
                        <div class="key-info-item">
                            <strong>Hash:</strong> SHA-256
                        </div>
                        <div class="key-info-item">
                            <strong>Ng√†y t·∫°o:</strong> ${new Date().toLocaleString('vi-VN')}
                        </div>
                    </div>
                    <div class="key-fingerprint">
                        <strong>Fingerprint:</strong><br>${fingerprint}
                    </div>
                `;

                const publicKeyDisplay = document.getElementById('publicKeyDisplay');
                const publicKeyContent = document.getElementById('publicKeyContent');
                publicKeyContent.textContent = publicKeyPem;
                publicKeyDisplay.style.display = 'block';
            }

            async generateKeyFingerprint(publicKey) {
                const publicKeyData = await crypto.subtle.exportKey('spki', publicKey);
                const hash = await crypto.subtle.digest('SHA-256', publicKeyData);
                const hashArray = Array.from(new Uint8Array(hash));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join(':').toUpperCase();
            }

            arrayBufferToPem(buffer, label) {
                const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));
                const formatted = base64.match(/.{1,64}/g).join('\n');
                return `-----BEGIN ${label}-----\n${formatted}\n-----END ${label}-----`;
            }

            pemToArrayBuffer(pem) {
                const base64 = pem
                    .replace(/-----BEGIN.*-----/, '')
                    .replace(/-----END.*-----/, '')
                    .replace(/\s/g, '');
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes.buffer;
            }

            async handlePublicKeyImport(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const content = await this.readFileAsText(file);
                    const keyData = this.pemToArrayBuffer(content);
                    
                    const importedKey = await crypto.subtle.importKey(
                        'spki',
                        keyData,
                        {
                            name: 'RSA-PSS',
                            hash: 'SHA-256'
                        },
                        true,
                        ['verify']
                    );

                    this.publicKey = importedKey;
                    await this.displayImportedKeyInfo(importedKey);
                    this.showStatus('Public key ƒë√£ ƒë∆∞·ª£c nh·∫≠p th√†nh c√¥ng!', 'success');
                    
                } catch (error) {
                    this.showStatus('L·ªói khi nh·∫≠p public key: ' + error.message, 'error');
                }
                
                this.updateButtonStates();
            }

            async displayImportedKeyInfo(publicKey) {
                const fingerprint = await this.generateKeyFingerprint(publicKey);
                const keyInfo = document.getElementById('keyInfo');
                
                keyInfo.innerHTML = `
                    <div class="status success">
                        ‚úÖ Public key ƒë√£ ƒë∆∞·ª£c nh·∫≠p (ch·ªâ x√°c th·ª±c)
                    </div>
                    <div class="key-fingerprint">
                        <strong>Fingerprint:</strong><br>${fingerprint}
                    </div>
                `;

                const publicKeyData = await crypto.subtle.exportKey('spki', publicKey);
                const publicKeyPem = this.arrayBufferToPem(publicKeyData, 'PUBLIC KEY');
                
                const publicKeyDisplay = document.getElementById('publicKeyDisplay');
                const publicKeyContent = document.getElementById('publicKeyContent');
                publicKeyContent.textContent = publicKeyPem;
                publicKeyDisplay.style.display = 'block';
            }

            async exportPublicKey() {
                if (!this.publicKey) return;

                try {
                    const publicKeyData = await crypto.subtle.exportKey('spki', this.publicKey);
                    const publicKeyPem = this.arrayBufferToPem(publicKeyData, 'PUBLIC KEY');
                    
                    const blob = new Blob([publicKeyPem], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `public_key_${Date.now()}.pem`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showStatus('Public key ƒë√£ ƒë∆∞·ª£c xu·∫•t!', 'success');
                    
                } catch (error) {
                    this.showStatus('L·ªói khi xu·∫•t public key: ' + error.message, 'error');
                }
            }

            async downloadPublicKey() {
                if (!this.publicKey) return;

                try {
                    const publicKeyData = await crypto.subtle.exportKey('spki', this.publicKey);
                    const publicKeyPem = this.arrayBufferToPem(publicKeyData, 'PUBLIC KEY');
                    const blob = new Blob([publicKeyPem], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `public_key_${Date.now()}.pem`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.showStatus('Public key ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng d∆∞·ªõi d·∫°ng PEM!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫£i public key: ' + error.message, 'error');
                }
            }

            async copyPublicKey() {
                const publicKeyContent = document.getElementById('publicKeyContent');
                if (!publicKeyContent.textContent) return;

                try {
                    await navigator.clipboard.writeText(publicKeyContent.textContent);
                    this.showStatus('Public key ƒë√£ ƒë∆∞·ª£c copy v√†o clipboard!', 'success');
                } catch (error) {
                    this.showStatus('Kh√¥ng th·ªÉ copy public key', 'error');
                }
            }

            async handleRecipientKeyDrop(e) {
                e.preventDefault();
                document.getElementById('recipientKeyArea').classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    await this.processRecipientKey(files[0]);
                }
            }

            async handleRecipientKeySelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                await this.processRecipientKey(file);
            }

            async processRecipientKey(file) {
                // Ch·ªâ cho ph√©p file .pem, .pub, .key
                const allowedExt = ['.pem', '.pub', '.key'];
                const fileName = file.name.toLowerCase();
                if (!allowedExt.some(ext => fileName.endsWith(ext))) {
                    this.showStatus('Ch·ªâ cho ph√©p file .pem, .pub, .key!', 'error');
                    return;
                }
                try {
                    const content = await this.readFileAsText(file);
                    const keyData = this.pemToArrayBuffer(content);
                    
                    const importedKey = await crypto.subtle.importKey(
                        'spki',
                        keyData,
                        {
                            name: 'RSA-OAEP',
                            hash: 'SHA-256'
                        },
                        true,
                        ['encrypt']
                    );

                    this.recipientPublicKey = importedKey;
                    const fingerprint = await this.generateKeyFingerprint(importedKey);
                    
                    const recipientKeyInfo = document.getElementById('recipientKeyInfo');
                    recipientKeyInfo.innerHTML = `
                        <div class="file-info">
                            <p><strong>T√™n file:</strong> ${file.name}</p>
                            <p><strong>K√≠ch th∆∞·ªõc:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
                            <p><strong>Th·ªùi gian:</strong> ${new Date(file.lastModified).toLocaleString('vi-VN')}</p>
                        </div>
                        <div class="status success">
                            ‚úÖ Public key c·ªßa ng∆∞·ªùi nh·∫≠n ƒë√£ ƒë∆∞·ª£c nh·∫≠p
                        </div>
                        <div class="key-fingerprint">
                            <strong>Fingerprint:</strong><br>${fingerprint}
                        </div>
                    `;
                    
                    this.showStatus('Public key c·ªßa ng∆∞·ªùi nh·∫≠n ƒë√£ ƒë∆∞·ª£c nh·∫≠p th√†nh c√¥ng!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi nh·∫≠p public key c·ªßa ng∆∞·ªùi nh·∫≠n: ' + error.message, 'error');
                }
                
                this.updateButtonStates();
            }

            async handleSignatureFileDrop(e) {
                e.preventDefault();
                document.getElementById('signatureFileArea').classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    await this.processSignatureFile(files[0]);
                }
            }

            async handleSignatureFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                await this.processSignatureFile(file);
            }

            async processSignatureFile(file) {
                try {
                    const content = await this.readFileAsText(file);
                    this.senderSignature = JSON.parse(content);
                    
                    const signatureFileInfo = document.getElementById('signatureFileInfo');
                    signatureFileInfo.innerHTML = `
                        <div class="file-info">
                            <p><strong>T√™n file:</strong> ${file.name}</p>
                            <p><strong>K√≠ch th∆∞·ªõc:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
                            <p><strong>Th·ªùi gian:</strong> ${new Date(file.lastModified).toLocaleString('vi-VN')}</p>
                        </div>
                    `;
                    
                    this.showStatus('File ch·ªØ k√Ω ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi x·ª≠ l√Ω file ch·ªØ k√Ω: ' + error.message, 'error');
                }
                
                this.updateButtonStates();
            }

            handleDragOver(e) {
                e.preventDefault();
                e.target.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.target.classList.remove('dragover');
            }

            handleSignatureDragOver(e) {
                e.preventDefault();
                document.getElementById('signatureFileArea').classList.add('dragover');
            }

            handleSignatureDragLeave(e) {
                e.preventDefault();
                document.getElementById('signatureFileArea').classList.remove('dragover');
            }

            async handleDrop(e) {
                e.preventDefault();
                document.getElementById('fileInputArea').classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                await this.processFiles(files);
            }

            async handleFileSelect(e) {
                const files = Array.from(e.target.files);
                await this.processFiles(files);
            }

            async processFiles(files) {
                this.files = files;
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                for (const file of files) {
                    const fileInfo = document.createElement('div');
                    fileInfo.className = 'file-info';
                    fileInfo.innerHTML = `
                        <p><strong>T√™n file:</strong> ${file.name}</p>
                        <p><strong>K√≠ch th∆∞·ªõc:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
                        <p><strong>Lo·∫°i:</strong> ${file.type || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    `;
                    fileList.appendChild(fileInfo);
                }

                this.showStatus(`${files.length} file ƒë√£ ƒë∆∞·ª£c ch·ªçn!`, 'success');
                this.updateButtonStates();
            }

            async readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsText(file);
                });
            }

            async generateSignature() {
                if (!this.privateKey || !this.files.length) return;

                const btn = document.getElementById('generateSignatureBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang t·∫°o ch·ªØ k√Ω...';

                try {
                    this.signatures = {};
                    for (const file of this.files) {
                        const arrayBuffer = await file.arrayBuffer();
                        const signature = await crypto.subtle.sign(
                            {
                                name: 'RSA-PSS',
                                saltLength: 32
                            },
                            this.privateKey,
                            arrayBuffer
                        );

                        this.signatures[file.name] = {
                            signature: Array.from(new Uint8Array(signature)),
                            timestamp: new Date().toISOString(),
                            fileName: file.name,
                            fileSize: file.size
                        };
                    }

                    const signatureInfo = document.getElementById('signatureInfo');
                    signatureInfo.innerHTML = `
                        <div class="status success">
                            ‚úÖ ${Object.keys(this.signatures).length} ch·ªØ k√Ω s·ªë ƒë√£ ƒë∆∞·ª£c t·∫°o
                        </div>
                        <div class="signature-display">
                            ${Object.keys(this.signatures).map(name => 
                                `<div><strong>${name}:</strong> ${this.signatures[name].signature.slice(0, 50).join(', ')}...</div>`
                            ).join('')}
                        </div>
                    `;

                    this.showStatus('Ch·ªØ k√Ω s·ªë ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫°o ch·ªØ k√Ω: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üîè T·∫°o Ch·ªØ K√Ω S·ªë';
                    this.updateButtonStates();
                }
            }

            async verifySignature() {
                if (!this.publicKey || !this.files.length || !Object.keys(this.signatures).length) return;

                const btn = document.getElementById('verifySignatureBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang x√°c th·ª±c...';

                try {
                    const signatureInfo = document.getElementById('signatureInfo');
                    let allValid = true;

                    for (const file of this.files) {
                        const signatureData = this.signatures[file.name];
                        if (!signatureData) continue;

                        const arrayBuffer = await file.arrayBuffer();
                        const signature = new Uint8Array(signatureData.signature);
                        
                        const isValid = await crypto.subtle.verify(
                            {
                                name: 'RSA-PSS',
                                saltLength: 32
                            },
                            this.publicKey,
                            signature,
                            arrayBuffer
                        );

                        if (!isValid) allValid = false;
                    }

                    signatureInfo.innerHTML = `
                        <div class="status ${allValid ? 'success' : 'error'}">
                            ${allValid ? '‚úÖ T·∫•t c·∫£ ch·ªØ k√Ω h·ª£p l·ªá!' : '‚ùå M·ªôt s·ªë ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá!'}
                        </div>
                    `;
                    
                    this.showStatus(allValid ? 'X√°c th·ª±c ch·ªØ k√Ω th√†nh c√¥ng!' : 'X√°c th·ª±c ch·ªØ k√Ω th·∫•t b·∫°i!', allValid ? 'success' : 'error');
                } catch (error) {
                    this.showStatus('L·ªói khi x√°c th·ª±c ch·ªØ k√Ω: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '‚úÖ X√°c Th·ª±c Ch·ªØ K√Ω';
                }
            }

            async downloadSignature() {
                if (!Object.keys(this.signatures).length) return;

                try {
                    const signatureData = {
                        signatures: this.signatures,
                        createdAt: new Date().toISOString(),
                        version: '1.0'
                    };

                    const blob = new Blob([JSON.stringify(signatureData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `signatures_${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showStatus('Ch·ªØ k√Ω ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫£i ch·ªØ k√Ω: ' + error.message, 'error');
                }
            }

            async encryptFiles() {
                if (!this.files.length || !this.recipientPublicKey) return;

                const btn = document.getElementById('encryptBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang m√£ h√≥a...';

                try {
                    this.encryptedFiles = {};

                    for (const file of this.files) {
                        const arrayBuffer = await file.arrayBuffer();
                        const iv = crypto.getRandomValues(new Uint8Array(12));
                        const aesKey = await crypto.subtle.generateKey(
                            {
                                name: 'AES-GCM',
                                length: 256
                            },
                            true,
                            ['encrypt']
                        );

                        const encryptedContent = await crypto.subtle.encrypt(
                            {
                                name: 'AES-GCM',
                                iv: iv
                            },
                            aesKey,
                            arrayBuffer
                        );

                        const exportedKey = await crypto.subtle.exportKey('raw', aesKey);
                        const encryptedKey = await crypto.subtle.encrypt(
                            {
                                name: 'RSA-OAEP'
                            },
                            this.recipientPublicKey,
                            exportedKey
                        );

                        this.encryptedFiles[file.name] = {
                            encryptedContent: Array.from(new Uint8Array(encryptedContent)),
                            encryptedKey: Array.from(new Uint8Array(encryptedKey)),
                            iv: Array.from(iv),
                            fileName: file.name
                        };
                    }

                    this.showStatus('File ƒë√£ ƒë∆∞·ª£c m√£ h√≥a th√†nh c√¥ng!', 'success');
                    const fileList = document.getElementById('fileList');
                    fileList.innerHTML += `
                        <div class="status success">
                            ‚úÖ ${Object.keys(this.encryptedFiles).length} file ƒë√£ ƒë∆∞·ª£c m√£ h√≥a
                        </div>
                    `;
                } catch (error) {
                    this.showStatus('L·ªói khi m√£ h√≥a file: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üîí M√£ H√≥a File';
                    this.updateButtonStates();
                }
            }

            async encryptForRecipient() {
                if (!this.recipientPublicKey || !this.files.length) return;

                const btn = document.getElementById('encryptForRecipientBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang m√£ h√≥a...';

                try {
                    for (const file of this.files) {
                        const arrayBuffer = await file.arrayBuffer();
                        const iv = crypto.getRandomValues(new Uint8Array(12));
                        const aesKey = await crypto.subtle.generateKey(
                            {
                                name: 'AES-GCM',
                                length: 256
                            },
                            true,
                            ['encrypt']
                        );

                        const encryptedContent = await crypto.subtle.encrypt(
                            {
                                name: 'AES-GCM',
                                iv: iv
                            },
                            aesKey,
                            arrayBuffer
                        );

                        const exportedKey = await crypto.subtle.exportKey('raw', aesKey);
                        const encryptedKey = await crypto.subtle.encrypt(
                            {
                                name: 'RSA-OAEP'
                            },
                            this.recipientPublicKey,
                            exportedKey
                        );

                        const encryptedData = {
                            encryptedContent: Array.from(new Uint8Array(encryptedContent)),
                            encryptedKey: Array.from(new Uint8Array(encryptedKey)),
                            iv: Array.from(iv),
                            fileName: file.name,
                            timestamp: new Date().toISOString()
                        };

                        const blob = new Blob([JSON.stringify(encryptedData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `encrypted_${file.name}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }

                    this.showStatus('File ƒë√£ ƒë∆∞·ª£c m√£ h√≥a cho ng∆∞·ªùi nh·∫≠n!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi m√£ h√≥a: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üîí M√£ H√≥a Cho Ng∆∞·ªùi Nh·∫≠n';
                    this.updateButtonStates();
                }
            }

            async verifyRecipientSignature() {
                if (!this.publicKey || !this.senderSignature || !this.files.length) return;

                const btn = document.getElementById('verifyRecipientSignatureBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang x√°c th·ª±c...';

                try {
                    const verificationResult = document.getElementById('verificationResult');
                    let allValid = true;

                    for (const file of this.files) {
                        const signatureData = this.senderSignature.signatures?.[file.name];
                        if (!signatureData) continue;

                        const arrayBuffer = await file.arrayBuffer();
                        const signature = new Uint8Array(signatureData.signature);
                        
                        const isValid = await crypto.subtle.verify(
                            {
                                name: 'RSA-PSS',
                                saltLength: 32
                            },
                            this.publicKey,
                            signature,
                            arrayBuffer
                        );

                        if (!isValid) allValid = false;
                    }

                    verificationResult.innerHTML = `
                        <div class="status ${allValid ? 'success' : 'error'}">
                            ${allValid ? '‚úÖ Ch·ªØ k√Ω t·ª´ ng∆∞·ªùi g·ª≠i h·ª£p l·ªá!' : '‚ùå Ch·ªØ k√Ω t·ª´ ng∆∞·ªùi g·ª≠i kh√¥ng h·ª£p l·ªá!'}
                        </div>
                    `;
                    
                    this.showStatus(allValid ? 'X√°c th·ª±c ch·ªØ k√Ω th√†nh c√¥ng!' : 'X√°c th·ª±c ch·ªØ k√Ω th·∫•t b·∫°i!', allValid ? 'success' : 'error');
                } catch (error) {
                    this.showStatus('L·ªói khi x√°c th·ª±c ch·ªØ k√Ω: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '‚úÖ X√°c Th·ª±c Ch·ªØ K√Ω';
                }
            }

            async generateQR() {
                if (!Object.keys(this.encryptedFiles).length) return;

                const btn = document.getElementById('generateQRBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang t·∫°o m√£ QR...';

                try {
                    const qrCodeDiv = document.getElementById('qrCode');
                    qrCodeDiv.innerHTML = '';

                    // For simplicity, we'll create a QR code for the first encrypted file
                    const firstFileName = Object.keys(this.encryptedFiles)[0];
                    const encryptedData = this.encryptedFiles[firstFileName];
                    const qrData = JSON.stringify({
                        fileName: encryptedData.fileName,
                        encryptedKey: encryptedData.encryptedKey,
                        iv: encryptedData.iv
                    });

                    // Using QRCode.js library (you'll need to include this)
                    // For now, we'll simulate QR code generation
                    qrCodeDiv.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrData)}" alt="QR Code">`;
                    
                    this.showStatus('M√£ QR ƒë√£ ƒë∆∞·ª£c t·∫°o!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫°o m√£ QR: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'T·∫°o M√£ QR';
                    this.updateButtonStates();
                }
            }

            async generateShareLink() {
                if (!Object.keys(this.encryptedFiles).length) return;

                const btn = document.getElementById('generateLinkBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang t·∫°o li√™n k·∫øt...';

                try {
                    const shareStatus = document.getElementById('shareStatus');
                    const expireTime = document.getElementById('expireTime');
                    
                    // Simulate generating a share link
                    const linkId = `link_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const expireDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now
                    
                    this.shareLinks[linkId] = {
                        files: this.encryptedFiles,
                        expires: expireDate.toISOString()
                    };

                    const shareUrl = `${window.location.origin}/share/${linkId}`;
                    
                    shareStatus.textContent = 'Li√™n k·∫øt ƒë√£ s·∫µn s√†ng';
                    expireTime.textContent = expireDate.toLocaleString('vi-VN');
                    
                    // Copy link to clipboard
                    await navigator.clipboard.writeText(shareUrl);
                    this.showStatus(`Li√™n k·∫øt chia s·∫ª ƒë√£ ƒë∆∞·ª£c t·∫°o v√† copy: ${shareUrl}`, 'success');
                    
                } catch (error) {
                    this.showStatus('L·ªói khi t·∫°o li√™n k·∫øt: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üîó T·∫°o Li√™n K·∫øt';
                    this.updateButtonStates();
                }
            }

            async revokeShareLink() {
                if (!Object.keys(this.shareLinks).length) return;

                const btn = document.getElementById('revokeLinkBtn');
                btn.disabled = true;
                btn.innerHTML = 'üîÑ ƒêang thu h·ªìi...';

                try {
                    this.shareLinks = {};
                    const shareStatus = document.getElementById('shareStatus');
                    const expireTime = document.getElementById('expireTime');
                    
                    shareStatus.textContent = 'Ch∆∞a s·∫µn s√†ng';
                    expireTime.textContent = '-';
                    
                    this.showStatus('Li√™n k·∫øt chia s·∫ª ƒë√£ ƒë∆∞·ª£c thu h·ªìi!', 'success');
                } catch (error) {
                    this.showStatus('L·ªói khi thu h·ªìi li√™n k·∫øt: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = 'üö´ Thu H·ªìi Li√™n K·∫øt';
                    this.updateButtonStates();
                }
            }

            showStatus(message, type) {
                const statusDiv = document.createElement('div');
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
                
                const container = document.querySelector('.container');
                container.insertBefore(statusDiv, container.firstChild);
                
                setTimeout(() => {
                    statusDiv.remove();
                }, 5000);
            }

            updateButtonStates() {
                document.getElementById('exportPublicKeyBtn').disabled = !this.publicKey;
                document.getElementById('downloadPublicKeyBtn').disabled = !this.publicKey;
                document.getElementById('generateSignatureBtn').disabled = !this.files.length || !this.privateKey;
                document.getElementById('encryptBtn').disabled = !this.files.length || !this.recipientPublicKey;
                document.getElementById('verifySignatureBtn').disabled = !this.files.length || !Object.keys(this.signatures).length;
                document.getElementById('downloadSignatureBtn').disabled = !Object.keys(this.signatures).length;
                document.getElementById('encryptForRecipientBtn').disabled = !this.files.length || !this.recipientPublicKey;
                document.getElementById('verifyRecipientSignatureBtn').disabled = !this.files.length || !this.senderSignature;
                document.getElementById('generateQRBtn').disabled = !Object.keys(this.encryptedFiles).length;
                document.getElementById('generateLinkBtn').disabled = !Object.keys(this.encryptedFiles).length;
                document.getElementById('revokeLinkBtn').disabled = !Object.keys(this.shareLinks).length;
            }
        }

        // Initialize the SecureFileTransfer
        const secureTransfer = new SecureFileTransfer();
    </script>
</body>
</html>